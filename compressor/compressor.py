import heapq
import itertools
#from compressor import node
import node
import requests


class Compressor:

    """
    The compressor class creates a Huffman encoding tree of a given text document. 
    """

    def __init__(self, file, eof=None):
        
        self.file = file
        self.frequencies = {}
        self.tree = None
        self.encoding = {}
        self.decoding = {}
        self.eof = eof
        self.canonical=True
        
    
    def get_frequencies_file(self):
        
        """
        Scan through a file and count the occurences of each character.
        """
        
        with open(self.file, 'r', encoding='utf-8') as f:
            for line in f:
                for char in line:
                    #char = char.encode('utf-8')
                    if char in self.frequencies:
                        self.frequencies[char] += 1
                        
                    else:
                        self.frequencies[char] = 1
                        
    def get_alphabet(self):
        """ Return a list consisting of the unique characters, or alphabet, seen in a given text"""
        
        return self.frequencies.keys()    
    
    def create_huffman_tree(self):
        """
        Create a tree representing the Huffman encoding for a given file. This function relies on the the frequencies distribution created by
        one of the get_frequencies functions
        """
        #Initialize the tree
        
        forest = []
        for frequency in self.frequencies.items():
            #frequency[0] is the char, frequency[1] is the count
            n= node.Node(None, None, None, frequency[0], frequency[1])
            heapq.heappush(forest, n)
            
        #Start combining trees
        while len(forest) > 1:
            candidate1 = heapq.heappop(forest)
            candidate2 = heapq.heappop(forest)
            tree = node.merge(candidate1, candidate2)
            heapq.heappush(forest, tree)
            
        #Now that we have a minimal tree, return it
        self.tree = heapq.heappop(forest)
    
    def parse_huffman_tree(self):
        """
        Return a dictionary where the keys are glyphs in the alphabet of a given document, and the
        values are the Huffman encoding in binary 
        """
        
        root = self.tree
        codeStr = ''
        self.dfs(root, codeStr)
        
        self.create_decoding()
        
        
    def dfs(self, node, codeStr):
        oneKid = False
        if node.char:
            self.encoding[node.char] = codeStr
            
        if node.left:
            #We have visited on child 
            oneKid = True
            codeStr += '0'
            self.dfs(node.left, codeStr)

        if node.right:
            if oneKid:
                #We've already visited one child, so remove the last 0 added and put on a one
                codeStr = codeStr[:-1] + '1'
            
            else:
                #Otherwise we did not add a 0 already at this depth so proceed
                codeStr += '1'
            self.dfs(node.right, codeStr)
    
    def create_decoding(self):
        """
        Construct a dictionary which can be used to decode a file given a known encoding.
        Function inverts the encoding dict of this object : keys are values, and values are keys
        from self.encoding.
        """
        keys = self.encoding.keys()
        
        for key in keys:
            self.decoding[self.encoding[key]] = key
    
    def encode(self):
        """
        Create an encoded file using an encoding previously generated by this object
        """
        
        #First, read the input file and transform it according to the encoding
        
        bytes = []
        with open(self.file, 'r', encoding='utf-8') as r:
            
            #Can this be done with a transform?
            bits = ''
            for line in r:
                
                #split the line into characters, perform the transformation, and join back 2getha
                bits += ''.join(map(lambda x:self.encoding[x], [char for char in line]))
        
        #add 0 padding to the end of the string  to make it a whole number of bytes
        
        padding = 8 - len(bits) % 8
        bits += '0' * padding
        
        
        #Get 8 chars from the encoded string, and convert this to a binary number
        bits = iter(bits)
        while(bits):
            byte = ''.join(list(itertools.islice(bits, 8)))
            if byte:
                byte = int(byte, 2)
                bytes.append(byte)
            else:
                break
                
        # Finished encoding the file, now write it
        with open ('encoded.bin', 'wb') as f:
            f.write(bytearray(bytes)) 
      
    def format_byte(self, byte):
        """
        Format a byte from the compressed stream for decoding
        """               
        #Convert the binary into an integer
        byte = int.from_bytes(byte, 'little')
        
        #Next convert that integer to a string
        byte = '{0:b}'.format(byte)
        
        #This conversion strips leading 0's, however we need them
        #If we have less than 8 bytes, pad the start with 0's
        """
        modulo = len(byte) % 8
        print(modulo)
        if modulo != 0:
            byte = '0' * (8-modulo) + byte
        """ 
        return byte
    
    def get_decoded(self, byte, startPos=0):
        for i in range(len(byte)):
            candidate = byte[startPos:i]
            print(candidate)
                
            if candidate in self.decoding:
                return self.encoding[candidate]
        
        return None
        
    def decode(self, fName = 'encoded.bin'):
        """
        Decode a file according to the encoding contained in this compressor object
        """
        toWrite = []
        with open(fName, 'rb') as f:
            
            
            byte = f.read(1)
            while byte:
                
                byteFormatted = self.format_byte(byte)
                #Decode the byte:
                decoded = self.get_decoded(byteFormatted)
                #We found a decoding, and by the no prefix property we know it is correct
                if decoded:
                        toWrite.append(self.decoding[byteFormatted])
                    
                else:
                    #Our code is larger than what was contained in 8 bytes. Try for something that 
                    #could be contained in 16
                    
                    #IF our code is between 8 and 16 bits, we need to add back 0's to the beginning
                    modulo = len(byteFormatted) % 8
                    if modulo != 0:
                        byteFormatted = '0' * (8-modulo) + byteFormatted
                    #Get the next byte and see if it is the key    
                    byteFormatted = self.format_byte(f.read(1)) + byteFormatted
                    if byteFormatted in self.decoding:
                        toWrite.append(self.decoding[byteFormatted])
                    else:
                        #TODO: Handle this case better
                        print('Error, encoding of some char was larger than 16 bits')
                        return
                    
                if byteFormatted != self.encode(self.eof):
                    byte = f.read(1)
                else:
                    break
                
    
    
if __name__ == '__main__':
    
    c = Compressor('../tests/warandpeace.txt',)
    c.get_frequencies_file()
    c.create_huffman_tree()
    c.parse_huffman_tree()
    c.encode()
    a = c.get_alphabet()
    print(len(a))
    #a = [char.decode('utf-8') for char in a]
    for char in a:
        #print(char.decode('utf-8'))
        print(u'\ufeff')
    #c.decode()